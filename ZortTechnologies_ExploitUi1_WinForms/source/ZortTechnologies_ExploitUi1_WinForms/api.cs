using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.WebSockets;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

//apis
using KrnlAPI;
using WeAreDevs_API;
//end of apis

//tuaxas spd
using ZortTechnologies_ExploitUi1_WinForms.Properties;
//end
namespace ZortTechnologies_ExploitUi1_WinForms
{
    internal class api
    {
        private class BasicInject
        {
            //credits to : wearedevs developers
            //im getted it on dnspy (reverseer engineering) for oxygenu injection+execution

            [DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
            [return: MarshalAs(UnmanagedType.Bool)]
            private static extern bool WaitNamedPipe(string name, int timeout);

            // Token: 0x06000034 RID: 52
            [DllImport("kernel32", CharSet = CharSet.Ansi, SetLastError = true)]
            internal static extern IntPtr LoadLibraryA(string lpFileName);

            // Token: 0x06000035 RID: 53
            [DllImport("kernel32", CharSet = CharSet.Ansi, ExactSpelling = true, SetLastError = true)]
            internal static extern UIntPtr GetProcAddress(IntPtr hModule, string procName);

            // Token: 0x06000036 RID: 54
            [DllImport("kernel32.dll", SetLastError = true)]
            [return: MarshalAs(UnmanagedType.Bool)]
            internal static extern bool FreeLibrary(IntPtr hModule);

            // Token: 0x06000037 RID: 55
            [DllImport("kernel32.dll")]
            internal static extern IntPtr OpenProcess(BasicInject.ProcessAccess dwDesiredAccess, [MarshalAs(UnmanagedType.Bool)] bool bInheritHandle, int dwProcessId);

            // Token: 0x06000038 RID: 56
            [DllImport("kernel32.dll", ExactSpelling = true, SetLastError = true)]
            internal static extern IntPtr VirtualAllocEx(IntPtr hProcess, IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);

            // Token: 0x06000039 RID: 57
            [DllImport("kernel32.dll", SetLastError = true)]
            internal static extern bool WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, byte[] lpBuffer, uint nSize, out UIntPtr lpNumberOfBytesWritten);

            // Token: 0x0600003A RID: 58
            [DllImport("kernel32.dll")]
            internal static extern IntPtr CreateRemoteThread(IntPtr hProcess, IntPtr lpThreadAttributes, uint dwStackSize, UIntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, out IntPtr lpThreadId);

            // Token: 0x0600003B RID: 59
            [DllImport("kernel32.dll", SetLastError = true)]
            internal static extern bool ReadProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, [Out] byte[] lpBuffer, int dwSize, out int lpNumberOfBytesRead);

            // Token: 0x0600003C RID: 60 RVA: 0x000026AC File Offset: 0x000008AC
            WeAreDevs_API.ExploitAPI wrd = new WeAreDevs_API.ExploitAPI();
            public bool InjectDLL(string dll, string proecessname)
            {
                if (dll == null)
                {
                    return false;
                }
                if (proecessname == null)
                {
                    return false;
                }
                if (Process.GetProcessesByName(proecessname).Length == 0)
                {
                    return false;
                }
                Process process = Process.GetProcessesByName(proecessname)[0];
                byte[] bytes = new ASCIIEncoding().GetBytes(dll);
                IntPtr hModule = BasicInject.LoadLibraryA("kernel32.dll");
                UIntPtr procAddress = BasicInject.GetProcAddress(hModule, "LoadLibraryA");
                BasicInject.FreeLibrary(hModule);
                if (procAddress == UIntPtr.Zero)
                {
                    return false;
                }
                IntPtr intPtr = BasicInject.OpenProcess(BasicInject.ProcessAccess.AllAccess, false, process.Id);
                if (intPtr == IntPtr.Zero)
                {
                    return false;
                }
                IntPtr intPtr2 = BasicInject.VirtualAllocEx(intPtr, (IntPtr)0, (uint)bytes.Length, 12288u, 4u);
                UIntPtr uintPtr;
                IntPtr intPtr3;
                return !(intPtr2 == IntPtr.Zero) && BasicInject.WriteProcessMemory(intPtr, intPtr2, bytes, (uint)bytes.Length, out uintPtr) && !(BasicInject.CreateRemoteThread(intPtr, (IntPtr)0, 0u, procAddress, intPtr2, 0u, out intPtr3) == IntPtr.Zero);
            }

            // Token: 0x02000004 RID: 4
            [Flags]
            public enum ProcessAccess
            {
                // Token: 0x04000006 RID: 6
                AllAccess = 1050235,
                // Token: 0x04000007 RID: 7
                CreateThread = 2,
                // Token: 0x04000008 RID: 8
                DuplicateHandle = 64,
                // Token: 0x04000009 RID: 9
                QueryInformation = 1024,
                // Token: 0x0400000A RID: 10
                SetInformation = 512,
                // Token: 0x0400000B RID: 11
                Terminate = 1,
                // Token: 0x0400000C RID: 12
                VMOperation = 8,
                // Token: 0x0400000D RID: 13
                VMRead = 16,
                // Token: 0x0400000E RID: 14
                VMWrite = 32,
                // Token: 0x0400000F RID: 15
                Synchronize = 1048576
            }

            public static bool NamedPipeExist(string pipeName)
            {
                bool result;
                try
                {
                    int timeout = 0;
                    if (!BasicInject.WaitNamedPipe(Path.GetFullPath(string.Format("\\\\.\\pipe\\{0}", pipeName)), timeout))
                    {
                        int lastWin32Error = Marshal.GetLastWin32Error();
                        if (lastWin32Error == 0)
                        {
                            return false;
                        }
                        if (lastWin32Error == 2)
                        {
                            return false;
                        }
                    }
                    result = true;
                }
                catch (Exception)
                {
                    result = false;
                }
                return result;
            }

        }
        KrnlAPI.MainAPI krnl = new KrnlAPI.MainAPI();

        WeAreDevs_API.ExploitAPI wrd = new WeAreDevs_API.ExploitAPI();
        BasicInject injector = new BasicInject();
        WebClient wc = new WebClient();
       // Form1 frm1 = new Form1();
        public void loadapis()
        {
            try
            {

                if (File.Exists("oxygen.dll"))
                {

                }
                else
                {
                    wc.DownloadFile("https://github.com/iDevastate/Oxygen-v2/raw/main/OxygenBytecode.vmp.dll", "oxygen.dll");
                }
                if (File.Exists(Directory.GetCurrentDirectory() + "\\krnl.dll"))
                {

                }
                else
                {
                    wc.DownloadFile(" https://k-storage.com/bootstrapper/files/krnl.dll", Directory.GetCurrentDirectory() + "\\krnl.dll");
                }

            }
            catch (Exception ex)
            {
                MessageBox.Show("Error !  : \n\n" + ex.Message);
            }

        }

        public void injectapi()
        {
            
            if (ZortTechnologies_ExploitUi1_WinForms.Properties.Settings.Default.api == 1)
            {
                if (File.Exists(Directory.GetCurrentDirectory() + @"\krnl.dll"))
                {
                  // krnl.();
                    if (!MainAPI.IsAttached())

                    {
                        MainAPI.Inject();
                    }
                    else
                    {
                        MainAPI.Inject();

                    }
                   
                }
                else
                {
                    loadapis();
                    injectapi();
                }
            }
            else if (ZortTechnologies_ExploitUi1_WinForms.Properties.Settings.Default.api == 2)
            {

                if (File.Exists(Directory.GetCurrentDirectory() + @"\oxygenu.dll"))
                {
                    if (new Pipe("OxygenU").Exists())
                    {
                        MessageBox.Show("Oxygen U Api Already Injected !", "Protector X Api Manager");
                    }
                    if (Process.GetProcessesByName("RobloxPlayerBeta").Length == 0)
                    {

                        MessageBox.Show("Please Open ROBLOX Before injecting Oxygen U!", "Protector X Api Manager");

                    }
                    else
                    {
                        injector.InjectDLL(Directory.GetCurrentDirectory() + "\\oxygen.dll", "RobloxPlayerBeta");

                    }
                }
                else
                {
                    loadapis();
                    injectapi();
                }
            }
            else if (ZortTechnologies_ExploitUi1_WinForms.Properties.Settings.Default.api == 3)
            {
                wrd.LaunchExploit();
            }
            

        }
        public void changeapi(int api)
        {
            Settings.Default.api = api;
            Settings.Default.Save();
        }
        public void execute(string script)
        {
            try
            {
                if (Settings.Default.api == 1)
                {
                    
                    if (MainAPI.IsAttached())
                    {
                        MainAPI.Execute(script);
                    }
                    else
                    {
                        injectapi();
                    }
                    
                }
                else if (Settings.Default.api == 2)
                {

                    Pipe pipe = new Pipe("OxygenU");
                    if (!pipe.Exists())
                    {
                        injectapi();
                        return;
                    }
                    if (script != null)
                    {
                        Pipe pipe2 = pipe;

                        pipe2.Write(script);
                        //oxy.Execute(script);
                    }
                }
                else if (Settings.Default.api == 3)
                {
                    wrd.SendLuaScript(script);
                }
                else if (Settings.Default.api == null & Settings.Default.api == 0)
                {
                    MessageBox.Show("Please Sellect Api From Settings");
                }
            }
            catch (Exception ex)
            {
                MessageBox.Show(ex.Message);
                //piroai.upper(ex.Message + "\n" + ex.Data + "\n" + ex.StackTrace + "\n" + ex.Source + "\n" + ex.InnerException);

            }
        }
    }
}
